*leap.txt*	Neovim's answer to the mouse

For Neovim version 0.10.0

==============================================================================
CONTENTS                                                         *leap-contents*

  Introduction ············································· |leap-introduction|
  Usage ··························································· |leap-usage|
  Mappings ····················································· |leap-mappings|
  Features ····················································· |leap-features|
  Configuration ·················································· |leap-config|
  Highlighting ················································ |leap-highlight|
  Events ························································· |leap-events|
  Extending Leap ············································· |leap-extensions|

==============================================================================
INTRODUCTION                                  *leap* *leap.nvim* *leap-introduction*

Leap is a general-purpose motion plugin for Neovim, building and improving
primarily on vim-sneak (https://github.com/justinmk/vim-sneak). Using some
clever ideas, it allows you to jump to any position in the visible editor area
very quickly, with near-zero mental overhead.

==============================================================================
USAGE                                                               *leap-usage*

• Initiate the search in a given scope (|leap-mappings|), and start typing a
  2-character pattern ({char1}{char2}).

• After typing {char1}, you see "labels" appearing next to some pairs. This is
  just a preview - labels only get active after finishing the pattern.
  *leap-preview*

• Type {char2}, which filters the matches. When the closest pair is unlabeled,
  you automatically jump there. In case that was your target, you can safely
  ignore the remaining labels - those will not conflict with any sensible
  command, and will disappear on the next keypress (|leap.opts.safe_labels|).
  *leap-autojump*

• Else: type the label character to jump to the given position. If there are
  more matches than available labels, you can move between groups with <space>
  and <backspace> (|leap.opts.keys|).

To move to the last character on a line, type `{char}<space>`. To move to an
empty line, type `<space><space>`. |leap-till-eol| |leap-to-eol|

See |leap-features| for lots of additional details.

==============================================================================
MAPPINGS                                                         *leap-mappings*

Leap defines some <Plug> keys aliasing calls to |leap.leap()|. To create
custom motions, simply call that function with your preferred arguments
instead. E.g., `<Plug>(leap-backward)` is a synonym for: >lua
    function () require('leap').leap { backward = true } end

Available <Plug> keys ~

    Key                         |  Search scope    |  Offset  |  |inclusive|
    ----------------------------|------------------|----------|-------------
    *<Plug>(leap)*                |  Current window  |          |  * (forward)
    *<Plug>(leap-from-window)*    |  Other windows   |          |
    *<Plug>(leap-anywhere)*       |  All windows     |          |
    *<Plug>(leap-forward)*        |  After cursor    |          |  *
    *<Plug>(leap-backward)*       |  Before cursor   |          |
    *<Plug>(leap-forward-till)*   |  After cursor    |  -1      |  *
    *<Plug>(leap-backward-till)*  |  Before cursor   |  +1      |

   See also |leap-target-ordering|.

Suggested arrangements ~

1. Default: >lua
    vim.keymap.set({'n', 'x', 'o'}, 's', '<Plug>(leap)')
    vim.keymap.set('n',             'S', '<Plug>(leap-from-window)')

2. Sneak-style: >lua
    vim.keymap.set({'n', 'x', 'o'}, 's',  '<Plug>(leap-forward)')
    vim.keymap.set({'n', 'x', 'o'}, 'S',  '<Plug>(leap-backward)')
    vim.keymap.set('n',             'gs', '<Plug>(leap-from-window)')

You might add a pair of keys for exclusive selection to any of the above: >lua
    vim.keymap.set({'x', 'o'}, 'x', '<Plug>(leap-forward-till)')
    vim.keymap.set({'x', 'o'}, 'X', '<Plug>(leap-backward-till)')

==============================================================================
FEATURES                                                         *leap-features*

Directional motions (like |<Plug>(leap-forward)|) can be preceded with
|[count]|, skipping labeling, and jumping directly to the n-th match. Also
works with |leap-shortcut| (`2s{char}<enter>`).

|forced-motion|s work, including |o_v| as inclusive/exclusive toggle.

If a |language-mapping| ('keymap') is active, Leap waits for keymapped
sequences as needed and searches for the keymapped result.

The last character on a line can be targeted by pressing <space> after it.
There is nothing special going on here: <space> is simply an alias for `\n`
and `\r`, set in |leap.opts.equivalence_classes| by default. *leap-till-eol*

To target actual EOL positions, including empty lines, press a newline alias
twice (pretend that each newline character is duplicated). *leap-to-eol*

The search can go horizontally offscreen for directional motions (those
targets can only be reached via |leap-traversal|).

Case sensitivity is determined by 'ignorecase' and 'smartcase'. If you want
specific settings for Leap motions, you can set these to temporary values in
|leap.opts.vim_opts|.

NOTE: 'smartcase' is experimentally supported for |leap-preview| too, but
there are serious caveats: it can only be applied on the first input
character, by design, since the second one just filters the already acquired
and _labeled_ targets (see |leap-wildcard-problem|). A related issue is that,
as of the current implementation, |leap-repeat| will not find the same matches
- while an `Ab` input with 'smartcase' will match both `Ab` and `AB` (see
above), repeat will only match `Ab`-s, like a normal search command would (it
is not a step-by-step replay of the original invocation's phases).
*leap-smartcase*

A same-character pair (`==`) will match a longer such sequence (`=====`) only
at the beginning, so that e.g. separator lines will not create unnecessary
noise and eat up all the labels.

|V| or |o_V| will make the search skip the current line.

                                                          *leap-target-ordering*
When searching bidirectionally (e.g., |<Plug>(leap)|), matches are sorted by
Euclidean (beeline) distance from the cursor, but the current line you're on,
and on that line, forward direction is prioritized. That is, you can be sure
that the targets right in front of you will be the first ones.

                                                           *leap-smart-autojump*
|leap-autojump| is only triggered if the remaining matches can be covered by a
set of "safe" target labels (keys never used right after leaping), otherwise
the cursor stays put, and an extended label set is loaded. To fine-tune or
disable this behaviour, see |leap.opts.safe_labels| and |leap.opts.labels|.

                                                    *leap-repeat* *leap-traversal*
At any stage, <enter> (|leap.opts.keys.next_target|) jumps to the next/closest
available target: pressing <enter> right away repeats the previous search;
`{char}<enter>` accepts the closest `{char}` match (can be used as a multiline
substitute for `fFtT` motions). *leap-shortcut*

In case of directional search, <enter> can continue traversing through the
rest of the targets (`s<enter><enter>...`). If you overshoot, <backspace>
(|leap.opts.keys.prev_target|) steps back.

There is a convenience function in the `user` module to set keys to repeat the
previous search without explicitly invoking Leap (`<enter><enter>...` instead
of `s<enter><enter>...`): >lua
    require('leap.user').set_repeat_keys('<enter>', '<backspace>', {
      -- When true, repeat in the direction of the last motion
      -- (by default, <cr>/<bs> always goes forward/backward).
      relative_directions = false,
      modes = {'n', 'x', 'o'},
    })
<
                                                               *leap-dot-repeat*
Operations can be repeated with |.|, if vim-repeat
(https://github.com/tpope/vim-repeat) is installed. Dot-repeat works as you
would expect, e.g., if you aimed for the 2nd target backwards, `.` will do the
same (the "beeline" |leap-target-ordering| is ignored).

                                  *leap-concealed-labels* *leap-preview-conflicts*
Labels in subsequent target groups are concealed with an empty block or a
middle dot, depending on the color scheme, and have a dimmed color.

In |leap-preview| phase, certain labels might be concealed in the first group
too, marking that there is a conflict or potential source of confusion (to be
resolved in the next step):

1. Two overlapping matches at window edge or EOL, where at least one of them
   is labeled. (A label beyond the edge would be shifted left a column, so
   there is no way to know which match is the owner.)

2. A label on top of another, unlabeled match. When typing quickly, this is
   in any case unsafe and unacceptable. >

                   #1           #2
    text        ...aab|     ...abac...
    match-1        aa?|        abL         L = label
    match-2         a?|          ac        ? = potential label
    preview     ...aa█|     ...ab█c...
<
See also: |leap.init_hl()|

==============================================================================
CONFIGURATION                                            *leap-config* *leap.opts*

Below is the description of all configurable values in the `opts` table, with
their defaults.

Example configuration: >lua
    local leap = require('leap')
    leap.opts.vim_opts['go.ignorecase'] = false
    leap.opts.keys.prev_target = '<s-enter>'
<
                                                             *leap.opts.preview*
`preview = true`

    Enable |leap-preview|. Can also be a function that only lets through
    selected matches, to reduce visual noise. It gets three characters as
    arguments: the character preceding the match, and the matched pair itself.
    Missing characters are represented by empty strings. Example: >lua

    -- Exclude whitespace and the middle of alphabetic words from preview:
    --   foobar[baaz] = quux
    --   ^----^^^--^^-^-^--^
    function (ch0, ch1, ch2)
      return not (
        ch1:match('%s') or
        ch0:match('%a') and ch1:match('%a') and ch2:match('%a')
      )
    end
<
    You can implement more involved checks here (camel case, keywords, you
    name it), but keep in mind that this function will be called for every
    single match, so efficiency is something to consider.

                          *leap-equivalence-class* *leap.opts.equivalence_classes*
`equivalence_classes = { ' \t\r\n' }`

    A character in search patterns will match any other in its equivalence
    class. The sets can either be defined as strings or tables.
    Example - whitespace, brackets, and quotes: >lua
        { ' \t\r\n', '([{', ')]}', '\'"`' }
<
    Note: If you want to be able to target empty lines and characters at the
    end of a line, keep an alias for `\n` and `\r`. |leap-till-eol|

    Note: Non-mutual aliases (wildcard characters), at least ones that work
    for the whole pattern, are not possible in Leap, because we cannot read
    your mind after the first input, and decide on which label to show for
    |leap-preview|. (Let's say you have entered `a`, and there is a
    `?` -> `x|y|z` wildcard mapping. We have no other choice than to cover all
    `ax|ay|az` matches with one shared label sequence, since you might type
    `?` next. But then `?xyz` is, by definition, a mutual alias group, there
    are no shortcuts anymore. |smartcase| is a specific instance of this
    issue: `x` -> `x|X`.) *leap-wildcard-problem*

                                                         *leap.opts.safe_labels*
`safe_labels = 'sfnut/SFNLHMUGTZ?'`

    These should be keys that you never use right after leaping (e.g. a search
    command), so that we can trigger |leap-autojump| whenever this list covers
    the rest of the matches. Any other key "falls through" to Normal mode.
    Setting the list to `''` effectively disables the autojump feature.

    Note: Operator-pending mode only checks this if |leap.opts.labels| is
    empty, since we should select the final target right away.

                                                              *leap.opts.labels*
`labels = 'sfnjklhodweimbuyvrgtaqpcxz/SFNJKLHODWEIMBUYVRGTAQPCXZ?'`

    Target labels to be used when there are more matches than
    |leap.opts.safe_labels| plus one. Setting the list to `''` forces
    |leap-autojump| to always be on. In that case, do not forget to set
    |leap.opts.keys.next_group| to something "safe" too.

A heuristic behind the default label lists: since the commands invoking the
motions are mapped to left-hand keys by default, we tend to prioritize
right-hand keys to get a better balance for the whole sequence on average.

                                                                *leap.opts.keys*
`keys =` >
    {
      next_target = '<enter>',
      prev_target = '<backspace>',
      next_group = '<space>',
      prev_group = '<backspace>',
    }

*leap.opts.keys.next_target*
Jump to the next available target (use the previous search pattern if no input
has been given). |leap-repeat|

*leap.opts.keys.prev_target*
Jump to the previous target (revert `next_target`).

*leap.opts.keys.next_group*
Shift to the next group of labeled targets.

*leap.opts.keys.prev_group*
Shift to the previous group of labeled targets (revert `next_group`).

Each value can be a table too, with alternatives. In `next_target` and
`prev_target`, subsequent keys only get active once we have the full search
pattern (no more input characters are needed). *leap-clever-repeat*
Example ("clever-s"): >lua
    local keys = require('leap').opts.keys
    keys.next_target = { '<enter>', 's' }
    keys.prev_target = { '<backspace>', 'S' }
<
Note: <esc> is hardcoded to exit Leap at any stage cleanly.

                                                            *leap.opts.vim_opts*
`vim_opts =` >
    {
      ['wo.scrolloff'] = 0,
      ['wo.sidescrolloff'] = 0,
      ['wo.conceallevel'] = 0,
      ['bo.modeline'] = false,
    }

Temporary |options| to be set on |LeapEnter|, and restored to their original
value upon |LeapLeave|. The keys should follow the above pattern, the prefix
corresponding to |vim.wo|, |vim.bo|, or |vim.go|.
Example - turning off |hlsearch| while leaping: >lua
    require('leap').opts.vim_opts['go.hlsearch'] = false
<
==============================================================================
HIGHLIGHTING                                                    *leap-highlight*

Leap uses the following highlight groups that you can configure to your own
liking (using |:hi| or |nvim_set_hl()|):

                                                                  *hl-LeapLabel*
LeapLabel	Target labels. |hi-link|ed to |hl-IncSearch| by default.
                Note: When set manually (not loaded as part of a color
                scheme), you should call |leap.init_hl()| afterwards, to
                update the look of |leap-concealed-labels|, derived from this
                group.

                                                                  *hl-LeapMatch*
LeapMatch	Search matches when doing |leap-traversal| without labels.
                Linked to |hl-Search| by default.
                To disable match highlights: >lua
                    vim.cmd 'hi! link LeapMatch None'
<
                                                               *hl-LeapBackdrop*
LeapBackdrop	In some cases it might be useful to apply certain settings on
                the whole search area, like disabling certain |attr-list|
                attributes, or linking to `Comment`, to make labels easier to
                see. This group is not set by default.

To preserve your custom settings, wrap them in a function, and define an
autocommand for |ColorScheme|: >lua

    vim.api.nvim_create_autocmd('ColorScheme', {
      group = vim.api.nvim_create_augroup('LeapColorTweaks', {}),
      callback = function ()
        -- Color-scheme-specific settings
        if vim.g.colors_name == 'foo' then
          -- Force using the defaults of Leap for this scheme.
          require('leap').init_hl(true)
        elseif vim.g.colors_name == 'bar' then
          vim.cmd 'hi! link LeapLabel Substitute'
        end
        -- General settings (apply to all schemes)
        vim.cmd 'hi! link LeapMatch None'
        -- Call this last, to ensure updating concealed labels.
        require('leap').init_hl()
      end
    })
<
leap.init_hl({force})                                           *leap.init_hl()*
    Sets the highlight groups to their defaults (without `force`, only as
    fallback). It also updates the look of |leap-concealed-labels|, based on
    the actual settings of |hl-LeapLabel|. Automatically called the first time
    Leap is loaded, and then on |ColorScheme| events.

    Parameters: ~
      • {force}  (boolean) optional: defaults to false. Set the groups without
                 |hi-default|.

==============================================================================
EVENTS                                                             *leap-events*

The |User| event is triggered with the following patterns on entering/exiting
Leap:

*LeapEnter*
*LeapLeave*

Custom behaviours for specific invocations ~

At runtime you can access the argument table passed to |leap.leap()| via
`require('leap').state.args`. This lets you flag any given invocation, and
define custom behaviours for it: >lua

    local function leap2 ()
      require('leap').leap { called_leap2 = true }
    end

    vim.api.nvim_create_autocmd('User', {
      pattern = 'LeapEnter',
      callback = function (event)
        if require('leap').state.args.called_leap2 then
          -- Put some special logic here (set options, highlight groups,
          -- mappings, anything you like), that will only apply to leap2().
          -- You can do cleanup in an analogous LeapLeave autocommand.
        end
      end
    })

==============================================================================
EXTENDING LEAP                                                 *leap-extensions*

There is more to Leap than meets the eye. On a general level, you should think
of it as less of a motion plugin and more of an engine for selecting visible
targets on the screen (acquired by arbitrary means), and doing arbitrary things
with them.

There are lots of ways you can extend the plugin and bend it to your will, and
the combinations of them give you almost infinite possibilities.

Instead of using the provided <Plug> keys (|leap-mappings|), you can also call
`leap()` directly:

leap({opts})                                                       *leap.leap()*
    Entry point for all |leap.nvim| actions.

    Parameters: ~
        {opts} Optional keyword arguments:
               • {backward}? (`boolean`, default: `false`) Search backward
                 instead of forward in the current window.
               • {windows}? (`table`) A list of windows (as |winid|s) to be
                 searched.
               • {offset}? (`-1|0|1`, default: `0`) Where to land with the
                 cursor compared to the target position.
               • {inclusive}? (`boolean`, default: `false`) Make operations
                 |inclusive| for forward jumps.
               • {opts}? (`table`) A table like |leap.opts|, to override any
                 default setting for the specific call. Example: >lua
                    require('leap').leap { opts = { safe_labels = '' } }
<
                 For map-like subtables it is also enough to specify only the
                 values to be overridden: >lua
                    require('leap').leap {
                      opts = { vim_opts = { ['go.ignorecase'] = false } }
                    }
<
                                                                       *leap-ft*
               • {inputlen}? (`0|1|2`, default: `2`) Set to 1 for |f|-like
                 motions. See an example of a full setup in the README.
                 Note: This feature is experimental, subject to change or
                 removal.
                                                           *leap-custom-pattern*
               • {pattern}?
                 (`string | fun(pattern: string, typed: string[]): string`)
                 A |regexp| pattern to be consumed by |search()|, or a
                 function returning such a pattern. (Remember to use raw
                 strings, or escape backslashes, as you want to pass those
                 literally to the Vim function from Lua.)

                 If user input is expected, the function gets the raw input
                 characters {typed}, as well as the prepared {pattern},
                 allowing you to modify it. Keep in mind, however, that in
                 case of |leap-preview|, the actual search pattern is based on
                 the first input character only - the second part is
                 substituted by a catch-all pattern. This means that regexp
                 modifiers that affect each character individually (e.g.
                 |/\c|) will not work with preview - such features need to be
                 implemented as black-box magic by the plugin. (Related:
                 |leap-wildcard-problem|.)

                 Examples: >lua
                    -- Search only for word beginnings:
                    pattern = function (pat) return '\\<'..pat end

                    -- Limit search scope to the current line:
                    -- (Note: It is best to always hardcode line numbers,
                    -- as we might move the cursor before the search starts.)
                    pattern = function (pat)
                      return '\\%'..vim.fn.line('.')..'l'..pat
                    end
<
                 Note: This feature is experimental, subject to change or
                 removal.
                                                           *leap-custom-targets*
               • {targets}? (`table|fun():table?`) A list of targets, or a
                 function returning such a list. The advantage of the latter
                 is that the function will be evaluated after |LeapEnter|
                 (that is, after setting temporary editor options, etc.), so
                 that you can even prompt the user for keyboard input while
                 already "in" Leap.
                 Targets are tables of arbitrary structure, with the only
                 mandatory field being `pos` - a (1,1)-indexed tuple; this is
                 the position of the label, and also the jump target, if no
                 custom {action} is provided. If you have targets in multiple
                 windows, you also need to provide a `wininfo` field for each
                 (|getwininfo()|).
                                                            *leap-custom-action*
               • {action}? (`fun(target):any?`) A callback to be executed by
                 Leap in place of the jump, taking the selected target as its
                 argument. (You can obviously implement some custom jump logic
                 here too.)

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
