*leap.txt*	Neovim's answer to the mouse

For Neovim version 0.10.0

==============================================================================
CONTENTS                                                         *leap-contents*

  Introduction ············································· |leap-introduction|
  Usage ··························································· |leap-usage|
  Mappings ····················································· |leap-mappings|
  Features ····················································· |leap-features|
  Configuration ·················································· |leap-config|
  Highlighting ················································ |leap-highlight|
  Events ························································· |leap-events|
  Extending Leap ············································· |leap-extensions|

==============================================================================
INTRODUCTION                                  *leap* *leap.nvim* *leap-introduction*

Leap is a general-purpose motion plugin for Neovim, building and improving
primarily on vim-sneak (https://github.com/justinmk/vim-sneak). Using some
clever ideas, it allows you to jump to any position in the visible editor area
very quickly, with near-zero mental overhead.

==============================================================================
USAGE                                                               *leap-usage*

• Initiate the search in a given scope (|leap-mappings|), and start typing a
  2-character pattern ({char1}{char2}).

• After typing {char1}, you see "labels" appearing next to some pairs. This is
  just a preview - labels only get active after finishing the pattern.
  *leap-preview*

• Type {char2}, which filters the matches. When the closest pair is unlabeled,
  you automatically jump there. In case that was your target, you can safely
  ignore the remaining labels - those will not conflict with any sensible
  command, and will disappear on the next keypress (|leap.opts.safe_labels|).
  *leap-autojump*

• Else: type the label character to jump to the given position. If there are
  more matches than available labels, you can move between groups with <space>
  and <backspace> (|leap.opts.keys|).

To move to the last character on a line, type `{char}<space>`. To move to an
empty line, type `<space><space>`. |leap-till-eol| |leap-to-eol|

See |leap-features| for lots of additional details.

==============================================================================
MAPPINGS                                                         *leap-mappings*

Leap defines some <Plug> keys aliasing calls to |leap.leap()|. To create
custom motions, simply call that function with your preferred arguments
instead. E.g., `<Plug>(leap-backward)` is a synonym for: >lua
    function () require('leap').leap { backward = true } end

Available <Plug> keys ~

    Key                         |  Search scope    |  Offset  |  |inclusive|
    ----------------------------|------------------|----------|-------------
    *<Plug>(leap)*                |  Current window  |          |  * (forward)
    *<Plug>(leap-from-window)*    |  Other windows   |          |
    *<Plug>(leap-anywhere)*       |  All windows     |          |
    *<Plug>(leap-forward)*        |  After cursor    |          |  *
    *<Plug>(leap-backward)*       |  Before cursor   |          |
    *<Plug>(leap-forward-till)*   |  After cursor    |  -1      |  *
    *<Plug>(leap-backward-till)*  |  Before cursor   |  +1      |

   See also |leap-target-ordering|.

Suggested arrangements ~

1. Default: >lua
    vim.keymap.set({'n', 'x', 'o'}, 's', '<Plug>(leap)')
    vim.keymap.set('n',             'S', '<Plug>(leap-from-window)')

2. Sneak-style: >lua
    vim.keymap.set({'n', 'x', 'o'}, 's',  '<Plug>(leap-forward)')
    vim.keymap.set({'n', 'x', 'o'}, 'S',  '<Plug>(leap-backward)')
    vim.keymap.set('n',             'gs', '<Plug>(leap-from-window)')

You might add a pair of keys for exclusive selection to any of the above: >lua
    vim.keymap.set({'x', 'o'}, 'x', '<Plug>(leap-forward-till)')
    vim.keymap.set({'x', 'o'}, 'X', '<Plug>(leap-backward-till)')

==============================================================================
FEATURES                                                         *leap-features*

Directional motions (like |<Plug>(leap-forward)|) can be preceded with
|[count]|, skipping labeling, and jumping directly to the n-th match. Also
works with |leap-shortcut| (`2s{char}<enter>`).

|forced-motion|s work, including |o_v| as inclusive/exclusive toggle.

If a |language-mapping| ('keymap') is active, Leap waits for keymapped
sequences as needed and searches for the keymapped result as expected.

The last character on a line can be targeted by pressing <space> after it.
There is nothing special going on here: <space> is simply an alias for `\n`
and `\r`, set in |leap.opts.equivalence_classes| by default. *leap-till-eol*

To target actual EOL positions, including empty lines, press the newline alias
twice (pretend that each newline character is duplicated). *leap-to-eol*

Same-character sequences (e.g. `-----`) are matched at one position only: by
default, at the start, and if `offset` in |leap.leap()| is positive, at the
end.

                                                          *leap-target-ordering*
When searching bidirectionally (e.g., |<Plug>(leap)|), matches are sorted by
Euclidean (beeline) distance from the cursor, but the current line you're on,
and on that line, forward direction is prioritized. That is, you can be sure
that the targets right in front of you will be the first ones.

                                                           *leap-smart-autojump*
|leap-autojump| is only triggered if the remaining matches can be covered by a
set of "safe" target labels (keys never used right after leaping), otherwise
the cursor stays put, and an extended label set is loaded. To fine-tune or
disable this behaviour, see |leap.opts.safe_labels| and |leap.opts.labels|.

                                                    *leap-repeat* *leap-traversal*
At any stage, <enter> (|leap.opts.keys.next_target|) jumps to the next/closest
available target: pressing `<enter>` right away repeats the previous search;
`{char}<enter>` accepts the closest `{char}` match (can be used as a multiline
substitute for `fFtT` motions). *leap-shortcut*

In case of directional search, <enter> can continue traversing through the
rest of the targets (`s<enter><enter>...`). If you overshoot, <backspace>
(|leap.opts.keys.prev_target|) steps back.

There is a convenience function in the `user` module to set keys to repeat the
previous search without explicitly invoking Leap (`<enter><enter>...` instead
of `s<enter><enter>...`): >lua
    require('leap.user').set_repeat_keys('<enter>', '<backspace>', {
      -- When true, repeat in the direction of the last motion
      -- (by default, <cr>/<bs> always goes forward/backward).
      relative_directions = false,
      modes = {'n', 'x', 'o'},
    })
<
                                                               *leap-dot-repeat*
Operations can be repeated with |.|, if vim-repeat
(https://github.com/tpope/vim-repeat) is installed. Dot-repeat works as you
would expect, e.g., if you aimed for the 2nd target backwards, `.` will do the
same (the "beeline" |leap-target-ordering| is ignored).

                                  *leap-concealed-labels* *leap-preview-conflicts*
Labels in subsequent target groups are concealed with an empty block or a
middle dot, depending on the color scheme, and have a dimmed color.

In |leap-preview| phase, certain labels might be concealed in the first group
too, marking that there is a conflict or potential source of confusion (to be
resolved in the next step):

1. Two overlapping matches at window edge or EOL, where at least one of them
   is labeled. (A label beyond the edge would be shifted left a column, so
   there is no way to know which match is the owner.)

2. A label on top of another, unlabeled match. When typing quickly, this is
   in any case unsafe and unacceptable. >

                   #1           #2
    text        ...aab|     ...abac...
    match-1        aa?|        abL         L = label
    match-2         a?|          ac        ? = potential label
    preview     ...aa█|     ...ab█c...
<
See also: |leap.init_hl()|

==============================================================================
CONFIGURATION                                            *leap-config* *leap.opts*

Below is the description of all configurable values in the `opts` table, with
their defaults.

Example configuration: >lua
    local leap = require('leap')
    leap.opts.case_sensitive = true
    leap.opts.keys.prev_target = '<s-enter>'
<
                                                      *leap.opts.case_sensitive*
`case_sensitive = false`

    Consider case in search patterns.

                                                 *leap.opts.equivalence_classes*
`equivalence_classes = { ' \t\r\n' }`

    A character in search patterns will match any other in its equivalence
    class. The sets can either be defined as strings or tables.
    Example - whitespace, brackets, and quotes: >lua
        { ' \t\r\n', '([{', ')]}', '\'"`' }
<
    Note: If you want to be able to target empty lines and characters at the
    end of a line, keep an alias for `\n` and `\r`. |leap-till-eol|

    Note: Wildcard characters (non-mutual aliases), at least ones that work
    for the whole pattern, are not possible in Leap, for the same reason that
    supporting |smartcase| is not possible: we cannot read your mind, and
    decide on which label to show for |leap-preview|. (Let's say you have
    entered `a`, and there is a `?` -> `x|y|z` wildcard mapping. Since we
    cannot show two different futures at the same time, the more general
    pattern should win in all places - that is, we have no other choice than
    to cover all `ax|ay|az` matches with one shared label sequence, since you
    might type `?` next. But then `?xyz` is in fact a mutual alias group,
    there are no shortcuts anymore. |smartcase| is a specific instance of this
    issue: `x` -> `x|X`.) *leap-wildcard-problem*

                                                      *leap.opts.preview_filter*
`preview_filter = nil`

    A function that only lets through selected matches for |leap-preview|, to
    reduce visual noise. It gets three characters as arguments: the character
    preceding the match (might be an empty string) and the matched pair
    itself. Examples: >lua

    -- Disable preview altogether.
    function () return false end

    -- Exclude whitespace and the middle of alphabetic words from preview:
    --   foobar[baaz] = quux
    --   ^----^^^--^^-^-^--^
    function (ch0, ch1, ch2)
      return not (
        ch1:match('%s') or
        ch0:match('%a') and ch1:match('%a') and ch2:match('%a')
      )
    end
<
    You can implement more involved checks here (camel case, keywords, you
    name it), but keep in mind that this function will be called for every
    single match, so efficiency is something to consider.

                                                         *leap.opts.safe_labels*
`safe_labels = 'sfnut/SFNLHMUGTZ?'`

    These should be keys that you never use right after leaping (e.g. a search
    command), so that we can trigger |leap-autojump| whenever this list covers
    the rest of the matches. Any other key "falls through" to Normal mode.

    Can be a string or a table. Setting it to `''` or `{}` effectively
    disables the autojump feature.

    Note: Operator-pending mode ignores this, and tries to use
    |leap.opts.labels|, since we should select the final target right away.

                                                              *leap.opts.labels*
`labels = 'sfnjklhodweimbuyvrgtaqpcxz/SFNJKLHODWEIMBUYVRGTAQPCXZ?'`

    Target labels to be used when there are more matches than
    |leap.opts.safe_labels| plus one.

    Can be a string or a table. Setting it to `''` or `{}` forces
    |leap-autojump| to always be on. In that case, do not forget to set
    |leap.opts.keys.next_group| to something "safe" too.

A heuristic behind the default label lists: since the commands invoking the
motions are mapped to left-hand keys by default, we tend to prioritize
right-hand keys to get a better balance for the whole sequence on average.

                                                                *leap.opts.keys*
`keys =` >
    {
      next_target = '<enter>',
      prev_target = '<backspace>',
      next_group = '<space>',
      prev_group = '<backspace>',
    }

*leap.opts.keys.next_target*
Jump to the next available target (use the previous search pattern if no input
has been given). |leap-repeat|

*leap.opts.keys.prev_target*
Jump to the previous target (revert `next_target`).

*leap.opts.keys.next_group*
Shift to the next group of labeled targets.

*leap.opts.keys.prev_group*
Shift to the previous group of labeled targets (revert `next_group`).

Each value can be a table too, with alternatives. In `next_target` and
`prev_target`, subsequent keys only get active once we have the full search
pattern (no more input characters are needed). Example ("clever-s"):
>lua
    local keys = require('leap').opts.keys
    keys.next_target = { '<enter>', 's' }
    keys.prev_target = { '<backspace>', 'S' }
<
Note: <esc> is hardcoded to exit Leap at any stage cleanly.

                                                            *leap.opts.vim_opts*
`vim_opts =` >
    {
      ['wo.scrolloff'] = 0,
      ['wo.sidescrolloff'] = 0,
      ['wo.conceallevel'] = 0,
      ['bo.modeline'] = false,
    }

Temporary |options| to be set on |LeapEnter|, and restored to their original
value upon |LeapLeave|. The keys should follow the above pattern, the prefix
corresponding to |vim.wo|, |vim.bo|, or |vim.go|.

Example - turning off |hlsearch| while leaping: >lua
    require('leap').opts.vim_opts['go.hlsearch'] = false
<
==============================================================================
HIGHLIGHTING                                                    *leap-highlight*

Leap uses the following highlight groups that you can configure to your own
liking (using |:hi| or |nvim_set_hl()|):

                                                                  *hl-LeapLabel*
LeapLabel		Target labels. |hi-link|ed to |hl-IncSearch| by default.
                        Note: When set manually (not loaded as part of a color
                        scheme), you should call |leap.init_hl()| afterwards,
                        to update the look of |leap-concealed-labels|, derived
                        from this group.

                                                                  *hl-LeapMatch*
LeapMatch		Search matches when doing |leap-traversal| without
                        labels. Linked to |hl-Search| by default.
                        To disable match highlights: >lua
                            vim.cmd 'highlight! link LeapMatch None'
<
                                                               *hl-LeapBackdrop*
LeapBackdrop		In some cases it might be useful to apply certain
                        settings on the whole search area, like disabling
                        certain |attr-list| attributes, or linking to
                        `Comment`, to make labels easier to see. This group is
                        not set by default.

To preserve your custom settings, wrap them in a function, and define an
autocommand for |ColorScheme|: >lua

    vim.api.nvim_create_autocmd('ColorScheme', {
      group = vim.api.nvim_create_augroup('LeapColorTweaks', {}),
      callback = function ()
        -- Color-scheme-specific settings
        if vim.g.colors_name == 'foo' then
          -- Force using the defaults of Leap for this scheme.
          require('leap').init_hl(true)
        elseif vim.g.colors_name == 'bar' then
          vim.cmd 'hi! link LeapLabel Substitute'
        end
        -- General settings (apply to all schemes)
        vim.cmd 'hi! link LeapMatch None'
        -- Call this last, to ensure updating concealed labels.
        require('leap').init_hl()
      end
    })
<
leap.init_hl({force})                                           *leap.init_hl()*
    Sets the highlight groups to their defaults (without `force`, only as
    fallback). It also updates the look of |leap-concealed-labels|, based on
    the actual settings of |hl-LeapLabel|. Automatically called the first time
    Leap is loaded, and then on |ColorScheme| events.

    Parameters: ~
      • {force}  (boolean) optional: defaults to false. Set the groups without
                 |hi-default|.

==============================================================================
EVENTS                                                             *leap-events*

The |User| event is triggered with the following patterns on entering/exiting
Leap:

*LeapEnter*
*LeapLeave*

Custom behaviours for specific invocations ~

At runtime you can access the argument table passed to |leap.leap()| via
`require('leap').state.args`. This lets you flag any given invocation, and
define custom behaviours for it: >lua

    local function leap2 ()
      require('leap').leap { called_leap2 = true }
    end

    vim.api.nvim_create_autocmd('User', {
      pattern = 'LeapEnter',
      callback = function (event)
        if require('leap').state.args.called_leap2 then
          -- Put some special logic here (set options, highlight groups,
          -- mappings, anything you like), that will only apply to leap2().
          -- You can do cleanup in an analogous LeapLeave autocommand.
        end
      end
    })

==============================================================================
EXTENDING LEAP                                                 *leap-extensions*

There is more to Leap than meets the eye. On a general level, you should think
of it as less of a motion plugin and more of an engine for selecting visible
targets on the screen (acquired by arbitrary means), and doing arbitrary things
with them.

There are lots of ways you can extend the plugin and bend it to your will, and
the combinations of them give you almost infinite possibilities.

Instead of using the provided <Plug> keys (|leap-mappings|), you can also call
`leap()` directly:

leap({opts})                                                       *leap.leap()*
    Entry point for all |leap.nvim| actions.

    Parameters: ~
        {opts} Optional keyword arguments:
               • {backward}? (`boolean`, default: `false`) Search backward
                 instead of forward in the current window.
               • {target_windows}? (`table`) A list of windows (as |winid|s)
                 to be searched.
               • {offset}? (`-1|0|1`, default: `0`) Where to land with the
                 cursor compared to the target position.
               • {inclusive_op}? (`boolean`, default: `false`) Make operations
                 |inclusive| for forward jumps.
               • {opts}? (`table`) A table like |leap.opts|, to override any
                 default setting for the specific call. Example: >lua
                    require('leap').leap { opts = { safe_labels = '' } }
<
                 For map-like subtables it is also enough to specify only the
                 values to be overridden: >lua
                    require('leap').leap {
                      opts = { vim_opts = { ['go.hlsearch'] = false } }
                    }
<
                                                                       *leap-ft*
               • {inputlen}? (`0|1|2`, default: `2`) Set to 1 for |f|-like
                 motions. See an example of a full setup in the README.
                 Note: This feature is experimental, subject to change or
                 removal.
                                                           *leap-custom-pattern*
               • {pattern}?
                 (`string | fun(pattern: string, typed: string[]): string`)
                 A |regexp| pattern to be consumed by |search()|, or a
                 function returning such a pattern. (Remember to escape
                 backslashes in the Lua string, as you want to pass those
                 literally to the Vim function.)

                 If user input is expected, the function will get the raw
                 input characters {typed}, as well as the prepared {pattern},
                 allowing you to modify it. Keep in mind, however, that in
                 case of |leap-preview|, the actual search pattern is based on
                 the first input character only - the second part is
                 substituted by the catch-all pattern |\_.|. This means that
                 regexp modifiers that affect each character individually
                 (e.g. |/\c|) will not work with preview - such features need
                 to be implemented as black-box magic by the plugin. (Related:
                 |leap-wildcard-problem|.)

                 Examples: >lua
                    -- Search only for word beginnings:
                    pattern = function (pat) return '\\<'..pat end
                    -- Limit search scope to the current line:
                    pattern = function (pat) return '\\%.l'..pat end
<
                 Note: This feature is experimental, subject to change or
                 removal.
                                                           *leap-custom-targets*
               • {targets}? (`table|fun():table?`) A list of targets, or a
                 function returning such a list. The advantage of the latter
                 is that the function will be evaluated after |LeapEnter|
                 (that is, after setting temporary editor options, etc.), so
                 that you can even prompt the user for keyboard input while
                 already "in" Leap.
                 Targets are tables of arbitrary structure, with the only
                 mandatory field being `pos` - a (1,1)-indexed tuple; this is
                 the position of the label, and also the jump target, if no
                 custom {action} is provided. If you have targets in multiple
                 windows, you also need to provide a `wininfo` field for each
                 (|getwininfo()|).
                                                            *leap-custom-action*
               • {action}? (`fun(target):any?`) A callback to be executed by
                 Leap in place of the jump, taking the selected target as its
                 argument. (You can obviously implement some custom jump logic
                 here too.)

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
